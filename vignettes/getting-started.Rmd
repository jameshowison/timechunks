---
title: "Getting Started with timechunks"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with timechunks}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse   = TRUE,
  comment    = "#>",
  fig.width  = 9,
  fig.height = 4,
  out.width  = "100%"
)
library(timechunks)
```

## What problem does this solve?

Institutional data often uses named periods that cross calendar year boundaries:

- `"Fall 2026"` runs from August 2026 to January 2027
- `"fa26"`, `"20268"`, and `"2026-27_1_08_Fall"` all mean the same thing
- Sorting `c("Spring 2027", "Fall 2026")` alphabetically gives the wrong order

`timechunks` provides a proper R vector type for these periods: parses any
common format, sorts chronologically, and survives all tidyverse operations.

---

## Setting up a calendar

Every `timechunks` function reads from a session-wide calendar set with
`use_chunk_preset()` or `set_chunk_calendar()`.

```{r calendar-preset}
# Built-in presets
use_chunk_preset("us_semester")     # Fall / Spring / Summer
# use_chunk_preset("us_quarter")    # Fall / Winter / Spring / Summer
# use_chunk_preset("uk_terms")      # Michaelmas / Lent / Easter
# use_chunk_preset("us_federal_fy") # Q1 / Q2 / Q3 / Q4
# use_chunk_preset("australia_semester")

default_chunk_calendar()$name
```

```{r calendar-custom, eval = FALSE}
# Or define your own
set_chunk_calendar(
  periods = list(
    list(name = "Fall",   code = "fa", start_mmdd = "08-23"),
    list(name = "Spring", code = "sp", start_mmdd = "01-15"),
    list(name = "Summer", code = "su", start_mmdd = "06-01")
  ),
  year_start_period = "Fall"
)
```

To rename a period — some institutions use "Winter" where others use
"Spring" — just change the `name` and `code` fields and keep the same
`start_mmdd`:

```{r calendar-rename}
set_chunk_calendar(
  periods = list(
    list(name = "Fall",   code = "fa", start_mmdd = "08-23"),
    list(name = "Winter", code = "wi", start_mmdd = "01-15"),
    list(name = "Summer", code = "su", start_mmdd = "06-01")
  ),
  year_start_period = "Fall"
)

time_chunk("wi27")               # parses "Winter 2027"
time_chunk("Winter 2027")        # text format works too
time_chunk("wi27") + 1L          # → Summer 2027
```

```{r calendar-rename-reset, include = FALSE}
use_chunk_preset("us_semester")
```

---

## Parsing

`time_chunk()` accepts any of four input formats and dispatches automatically.

```{r parsing}
use_chunk_preset("us_semester")

time_chunk("fa26")              # code format
time_chunk("Fall 2026")         # text format (also "2026 Fall")
time_chunk(20268)              # YYYYM numeric: 5 digits = months 1-9
time_chunk(202611)             # YYYYM numeric: 6 digits = months 10-12
time_chunk("2026-27_1_08_Fall") # composite key (round-trips from format())
```

All formats vectorize:

```{r vectorized}
time_chunk(c("fa26", "sp27", "su27"))
```

Sub-parsers are exported for explicit control:

```{r sub-parsers, eval = FALSE}
parse_chunk_code("fa26")
parse_chunk_text("Fall 2026")
parse_chunk_numeric(20268L)
```

---

## Accessing fields

All accessors return atomic vectors of the same length as the input.

```{r accessors}
x <- time_chunk(c("fa26", "sp27", "su27"))

chunk_name(x)    # period name
chunk_code(x)    # period code
chunk_year(x)    # calendar year of start date
chunk_ay(x)      # academic / fiscal year
chunk_index(x)   # position within the year (1, 2, 3, ...)

start_date(x)    # Date: period start
end_date(x)      # Date: period end
mid_date(x)      # Date: midpoint
```

---

## Formatting

```{r formatting}
x <- time_chunk("fa26")

format(x, style = "code")      # "fa26"
format(x, style = "name")      # "Fall 2026"
format(x, style = "ay")        # "2026-27"
format(x, style = "key")       # "2026-27_1_08_Fall"  (sortable, round-trips)
format(x, style = "iso_date")  # "2026-08-23"

# Glue-style template
format(x, style = "{ay} | {name}")
```

---

## Sorting

Sorting uses `start_date` as the comparison proxy, so `sort()` is always
chronological regardless of label format.

```{r sorting}
x <- time_chunk(c("sp27", "su27", "fa26"))
sort(x)
```

This works in `dplyr::arrange()` too:

```{r arrange, message = FALSE}
library(dplyr)

data.frame(
  semester   = time_chunk(c("sp27", "su27", "fa26")),
  enrollment = c(7100L, 3400L, 8200L)
) |>
  arrange(semester)
```

---

## Arithmetic

Move forward or backward by integer numbers of periods:

```{r arithmetic}
time_chunk("fa26") + 1L   # Spring 2027
time_chunk("fa26") + 2L   # Summer 2027
time_chunk("fa26") + 3L   # Fall 2027 (wraps to next academic year)
time_chunk("sp27") - 1L   # Fall 2026
```

Compute the distance between two periods:

```{r distance}
time_chunk("sp27") - time_chunk("fa26")   # 1L
time_chunk("fa27") - time_chunk("fa26")   # 3L  (one full year)
```

Generate sequences:

```{r seq}
seq(time_chunk("fa26"), time_chunk("fa27"), by = 1L)
```

Filter a sequence with standard subsetting — for example, drop all Summer terms:

```{r seq-filter}
all_terms <- seq(time_chunk("fa25"), time_chunk("fa27"), by = 1L)
academic_only <- all_terms[chunk_name(all_terms) != "Summer"]
academic_only
```

---

## dplyr / tidyr integration

`time_chunk` vectors are vctrs record objects and survive tidyverse operations
intact — `filter()`, `arrange()`, `mutate()`, and `pivot_longer()` all return
a column that is still a `time_chunk` with all fields accessible.

The `arrange()` case is the most telling: the rows come back in chronological
order even though alphabetical order would give a different result
(`"fa26" < "fa27" < "sp27" < "su27"` alphabetically vs.
`fa26 → sp27 → su27 → fa27` chronologically).

```{r dplyr, message = FALSE}
# Start with a time_chunk column already in the data frame
df <- data.frame(
  semester   = time_chunk(c("su27", "fa26", "fa27", "sp27")),
  enrollment = c(3400L, 8200L, 8500L, 7100L)
)

# Pass through filter → arrange → mutate; semester is still a time_chunk
result <- df |>
  filter(chunk_name(semester) != "Summer") |>  # drop Summer rows
  arrange(semester) |>                          # sort chronologically
  mutate(mid = mid_date(semester))              # access fields on the column

result

# Confirm: still a time_chunk after all three operations
is_time_chunk(result$semester)
```

`pivot_longer()` also preserves the column when it stays in place:

```{r pivot-longer, message = FALSE}
library(tidyr)

df |>
  mutate(enrollment_k = enrollment / 1000) |>
  pivot_longer(c(enrollment, enrollment_k), names_to = "metric", values_to = "value") |>
  select(semester, metric, value) |>
  arrange(semester)
```

### Wide tables for sharing

`pivot_wider()` requires text column names, so format `semester` to codes
first. The codes round-trip back to `time_chunk` via `time_chunk()` when
you pivot long again.

```{r pivot-wider, message = FALSE}
# Data arrives out of order and includes Summer
dept_df <- data.frame(
  dept     = rep(c("Engineering", "Liberal Arts"), each = 3),
  semester = time_chunk(c("sp27", "su26", "fa26",
                           "su26", "sp27", "fa26")),
  n        = c(1100L, 400L, 1200L, 320L, 750L, 800L)
)

# Long → wide: sort chronologically first so column order is chronological
wide <- dept_df |>
  arrange(semester) |>
  mutate(sem = format(semester, style = "code")) |>
  select(-semester) |>
  pivot_wider(names_from = sem, values_from = n)

wide

# Wide → long: codes parse back to time_chunk; arrange() sorts chronologically
# (su26 → fa26 → sp27), not alphabetically (fa26 → sp27 → su26)
wide |>
  pivot_longer(-dept, names_to = "sem", values_to = "n") |>
  mutate(semester = time_chunk(sem)) |>
  select(-sem) |>
  arrange(dept, semester)
```

---

## Time series operations

Because `time_chunk` sorts chronologically via its vctrs proxy, standard
tidyverse time series patterns work without any special wrappers. The
progression below builds from simple aggregation up to rolling windows.

```{r ts-setup, message = FALSE}
# Five semesters of enrollment data
ts_df <- data.frame(
  semester   = time_chunk(c("fa25", "sp26", "su26", "fa26", "sp27",
                             "su27", "fa27", "sp28")),
  enrollment = c(8100L, 7000L, 3100L, 8400L, 7200L, 3300L, 8600L, 7400L)
)
```

### 1. Group by academic year

`chunk_ay()` gives a plain character column you can pass straight to
`group_by()`:

```{r ts-group}
ts_df |>
  group_by(ay = chunk_ay(semester)) |>
  summarise(total = sum(enrollment), .groups = "drop")
```

### 2. Cumulative enrollment

`arrange(semester)` sorts rows chronologically; `cumsum()` then runs in the
right order:

```{r ts-cumsum}
ts_df |>
  arrange(semester) |>
  mutate(cumulative = cumsum(enrollment))
```

### 3. Semester-over-semester change

`lag()` looks back one row. Because the data is sorted by `semester`, "one
row back" means "one period back":

```{r ts-lag}
ts_df |>
  arrange(semester) |>
  mutate(
    change  = enrollment - lag(enrollment),
    pct_chg = round(change / lag(enrollment) * 100, 1)
  )
```

### 4. Rolling mean with `slider`

`slider::slide_dbl()` applies a function over a sliding window of rows.
After `arrange(semester)` the rows are in period order, so a window of
3 rows is a 3-period rolling mean:

```{r ts-rolling, message = FALSE}
library(slider)

ts_df |>
  arrange(semester) |>
  mutate(
    roll3 = slide_dbl(enrollment, mean, .before = 2, .complete = TRUE)
  )
```

`.before = 2` means "this row plus the 2 before it" (3-period window).
`.complete = TRUE` returns `NA` for the first two rows where a full window
is not yet available, rather than a partial mean.

---

## YYYYM format

Five- and six-digit integers encode year and month. The month is mapped to the
period that starts in that month (or the most recently started period):

```{r yyyym}
time_chunk(20261)   # January 2026  -> Spring 2026
time_chunk(20268)   # August 2026   -> Fall 2026  (Fall starts Aug-23)
time_chunk(202611)  # November 2026 -> Fall 2026
time_chunk(202701)  # January 2027  -> Spring 2027
```

For strict disambiguation, set `yyyym_strict = TRUE` in `set_chunk_calendar()`.
Any month that could map to multiple periods will error, prompting you to supply
an explicit `yyyym_map`.

---

## ggplot2 integration

See `vignette("ggplot2-visualization", package = "timechunks")` for a full
walkthrough of discrete, continuous, and segment visualization patterns.

Quick reference:

```{r ggplot-ref, eval = FALSE}
library(ggplot2)

# Discrete scale (equal spacing per period)
df |>
  mutate(sem_fct = as_chunk_factor(semester, labels = "code")) |>
  ggplot(aes(x = sem_fct, y = enrollment)) +
  geom_col()

# Continuous scale (proportional spacing by date)
df |>
  mutate(mid = mid_date(semester), lbl = format(semester, "code")) |>
  ggplot(aes(x = mid, y = enrollment)) +
  geom_line() +
  scale_x_date()
```
